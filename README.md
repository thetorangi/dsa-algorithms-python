# ğŸ“˜ Algorithms in Python

This repository is my personal **Data Structures & Algorithms (DSA) roadmap in Python**.  
The goal is to create a **library of algorithms** implemented from scratch,  
organized by topic, with explanations, complexity analysis, and examples.

No problem-site naming â€” only **pure algorithms**.

---

## ğŸš€ Roadmap of Algorithms

### ğŸ” Searching
- Linear Search
- Binary Search (Iterative & Recursive)
- Ternary Search
- Exponential Search
- Interpolation Search
- Jump Search

### ğŸ”¢ Sorting
- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort
- Counting Sort
- Shell Sort
- Tim Sort
- Radix Sort
- Bucket Sort

### ğŸ“Š Array-Based Algorithms
- Kadaneâ€™s Algorithm (Maximum Subarray Sum)
- Prefix Sum Technique
- Difference Array Technique
- Mooreâ€™s Voting Algorithm (Majority Element)
- Dutch National Flag Algorithm
- Maximum Product Subarray
- Trapping Rainwater
- Rotate Array (Reversal Algorithm)
- Maximum Circular Subarray Sum

### ğŸ¯ Two Pointers & Sliding Window
- Two Pointer Technique (Pair Sum, Remove Duplicates, etc.)
- Fixed-Size Sliding Window (e.g., Maximum Sum Subarray of size k)
- Variable-Size Sliding Window (e.g., Longest Substring with Conditions)
- Fast & Slow Pointers (Cycle Detection)

### ğŸ“¦ Stack Algorithms
- Balanced Parentheses
- Next Greater / Smaller Element
- Largest Rectangle in Histogram
- Stock Span Problem
- Evaluate Postfix Expression
- Infix â†” Postfix / Prefix Conversion
- Min Stack (Stack with O(1) Minimum)

### ğŸŒ€ Queue & Deque Algorithms
- Circular Queue Implementation
- Deque Applications (Sliding Window Maximum)
- LRU Cache (Queue + Hashing)
- Multi-source BFS (Rotten Oranges type)

### ğŸŒ³ Tree Algorithms
- Depth-First Traversals (Preorder, Inorder, Postorder)
- Breadth-First Traversal (Level Order)
- Height / Depth of Tree
- Count Nodes & Leaves
- Diameter of a Tree
- Lowest Common Ancestor
- Check Balanced Tree
- Invert / Mirror a Tree
- Validate Binary Search Tree
- Kth Smallest / Largest in BST
- Serialize & Deserialize a Tree

### ğŸ› ï¸ Heap / Priority Queue
- Min Heap & Max Heap Operations
- Heapify
- Heap Sort
- Kth Largest / Smallest Element
- Median of Data Stream
- Top-K Frequent Elements

### ğŸ“– Trie (Prefix Tree)
- Insert / Search / Delete Word
- Prefix Matching
- Word Break Problem (with Trie)
- Autocomplete Feature

### ğŸ” Recursion & Divide & Conquer
- Tower of Hanoi
- Fibonacci (Recursive + Optimized)
- Maximum / Minimum using Divide & Conquer
- Merge Sort / Quick Sort (Recursive Forms)

### ğŸ§® Dynamic Programming
- Fibonacci (Memoization + Tabulation)
- Climbing Stairs
- Longest Common Subsequence
- Longest Increasing Subsequence
- 0/1 Knapsack
- Subset Sum / Partition Equal Subset
- Coin Change (Min Coins & Count Ways)
- Matrix Chain Multiplication
- Edit Distance (Levenshtein)

### ğŸ’¡ Greedy Algorithms
- Activity Selection
- Huffman Coding
- Job Sequencing with Deadlines
- Minimum Spanning Tree (Primâ€™s & Kruskalâ€™s)
- Greedy Shortest Path (Dijkstraâ€™s Algorithm)

### ğŸŒ Graph Algorithms
- Graph Representation (Adjacency List & Matrix)
- Breadth-First Search (BFS)
- Depth-First Search (DFS)
- Connected Components
- Detect Cycle (Directed & Undirected Graphs)
- Topological Sorting (DFS + Kahnâ€™s Algorithm)
- Shortest Path (BFS in Unweighted Graphs)
- Dijkstraâ€™s Algorithm
- Bellman-Ford Algorithm
- Floyd-Warshall Algorithm
- Minimum Spanning Tree (Primâ€™s & Kruskalâ€™s)
- Strongly Connected Components (Kosarajuâ€™s Algorithm)
- Tarjanâ€™s Algorithm (Bridges, Articulation Points)

### âš¡ Advanced Data Structures & Algorithms
- Union-Find / Disjoint Set (Path Compression + Union by Rank)
- Binary Indexed Tree (Fenwick Tree)
- Segment Tree (Range Queries)
- String Matching Algorithms:
  - Knuthâ€“Morrisâ€“Pratt (KMP)
  - Rabin-Karp
  - Z-Algorithm

---

## ğŸ“‚ Repository Structure

```

dsa-algorithms-python/
â”‚
â”œâ”€â”€ Searching/
â”œâ”€â”€ Sorting/
â”œâ”€â”€ Arrays/
â”œâ”€â”€ TwoPointers\_SlidingWindow/
â”œâ”€â”€ Stack/
â”œâ”€â”€ Queue/
â”œâ”€â”€ Trees/
â”œâ”€â”€ Heap/
â”œâ”€â”€ Trie/
â”œâ”€â”€ Recursion/
â”œâ”€â”€ DynamicProgramming/
â”œâ”€â”€ Greedy/
â”œâ”€â”€ Graphs/
â”œâ”€â”€ Advanced/
â””â”€â”€ README.md

```

---

## ğŸ“Œ Goal
- Build a **single go-to resource** for DSA algorithms in Python
- Revise concepts quickly before interviews/contests
- Share knowledge with the community ğŸš€

---

## ğŸ“œ License
This project is licensed under the **MIT License** â€“ feel free to use, modify, and share with attribution.

---
